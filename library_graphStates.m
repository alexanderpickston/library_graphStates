(* ::Package:: *)

BeginPackage["GraphStates`"]


ClusterGenerator::usage = "Generates the graph state given by a graph.\nClusterGenerator[graph]"
FindLUequivalent::usage = "Find LC-equivalent applied on one vertex.\nFindLUequivalent[graph,vertex]"
LUfamily::usage = "Find a group of states LC-equivalent.\nNOTE: It might not be all the orbit.\nLUfamily[graph]"
LUfamilyISO::usage = "Select only the isomorphic graphs in LC-equivalent.\nLUfamilyISO[graph,vertex]"
Zmeasurement::usage ="Single Z-measurement\nZmeasurement[graph,vertex]"
FindSGroupXZSymbolic::usage = "Find the stabilizers generated by {\[DoubleStruckCapitalI],X,Z,-Z}.\nFindSGroupXZSymbolic[state]"
FindGraphFromXZStab::usage = "Given a list of X,Z stabilizers, apply all combinantions of {Hada, \[DoubleStruckCapitalI]} and select only those in the graph form i.e. one X per vertex\nFindGraphFromXZStab[state]"
DrawGraphFromStab::usage = "Drawn a graph given a list of stabilizers in the graph form i.e. one X per vertex\nDrawGraphFromStab[stabilizersList]"
Xmeasurement::usage = "Single X measurement on a graph vertex.\nXmeasurement[graph,vertex]"
Ymeasurement::usage = "Single Y measurement on a graph vertex.\nYmeasurement[graph,vertex]"
Zmeasurement::usage = "Single Z measurement on a graph vertex.\nZmeasurement[graph,vertex]"
graphSamples::usage = "Some build-in graphs: complete, kary, star, pie, cycle, grid and linear.\ngraphSamples[nqubit]\[LeftDoubleBracket]graphName\[RightDoubleBracket]"


Begin["`Private`"]


(* ::Input::Initialization:: *)
(* base vectors *)
h={{1},{0}};v={{0},{1}};d=1/Sqrt[2](h+v);a=1/Sqrt[2](h-v);r=1/Sqrt[2](h+I v);l=1/Sqrt[2](h-I v);

(* Pauli operators *)
idn=IdentityMatrix[2];sx=PauliMatrix[1];sy=PauliMatrix[2];sz=PauliMatrix[3];

(*Hadamard gate *)
hada=1/Sqrt[2] (sx+sz);


kron[u__]:=KroneckerProduct[u];


(* ::Input:: *)
(*graphSamples[n_]:=AssociationThread[*)
(*{*)
(*"complete",*)
(*"kary",*)
(*"star",*)
(*"pie",*)
(*"cycle",*)
(*"grid",*)
(*"linear"*)
(*}-> {*)
(*CompleteGraph[n,VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]],*)
(*KaryTree[n,VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]],*)
(*StarGraph[n,VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]],*)
(*WheelGraph[n,VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]],*)
(*CycleGraph[n,VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]],*)
(*GridGraph[{2,n+1},VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]],*)
(*GridGraph[{1,n},VertexShapeFunction->"Circle",*)
(*VertexSize->Medium,*)
(*VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],*)
(*EdgeStyle->Directive[Black,Thick],*)
(*VertexLabels->Placed["Name",{1/2,1/2}],*)
(*VertexLabelStyle->Directive[Black,font,15]]*)
(*}*)
(*];*)


(* List of rules for the application of the Pauli matrices to vector states *)
(* It is used in FindSGroupXZSymbolic function *)

opRules={
\[DoubleStruckCapitalI][qubit_]->{{H[qubit]->H[qubit],V[qubit]->V[qubit]}},
X[qubit_]->{{H[qubit]->V[qubit],V[qubit]->H[qubit]}},
-X[qubit_]->{{H[qubit]->-V[qubit],V[qubit]->-H[qubit]}},
I X[qubit_]->{{H[qubit]->I*V[qubit],V[qubit]->I*H[qubit]}},
-I X[qubit_]->{{H[qubit]->-I*V[qubit],V[qubit]->-I*H[qubit]}},
Z[qubit_]->{{H[qubit]->H[qubit],V[qubit]->-V[qubit]}},
-Z[qubit_]->{{H[qubit]->-H[qubit],V[qubit]->V[qubit]}},
I Z[qubit_]->{{H[qubit]->I*H[qubit],V[qubit]->-I*V[qubit]}},
-I Z[qubit_]->{{H[qubit]->I*H[qubit],V[qubit]->-I*V[qubit]}},
Y[qubit_]->{{H[qubit]->I*V[qubit],V[qubit]->-I*H[qubit]}},
-Y[qubit_]->{{H[qubit]->-I*V[qubit],V[qubit]->I*H[qubit]}},
I Y[qubit_]->{{H[qubit]->-V[qubit],V[qubit]->H[qubit]}},
-I Y[qubit_]->{{H[qubit]->V[qubit],V[qubit]->-H[qubit]}}
};


(* projectors |0x0| and |1x1| *)
proj00={{1,0},{0,0}};
proj11={{0,0},{0,1}};

(* generates a list of idn matrices and replace the projectors in the control and target position *)
(* then apply the kron to get the CZ matrix *)

CZ[control_,target_,nqubits_]:=(
kron@@(ReplacePart[Table[idn,{nqubits}],control-> proj00])+kron@@(ReplacePart[Table[idn,{nqubits}],{control-> proj11,target-> sz}])
);


Module[{graph,l,listTheEdge,czlist,generator,n},
ClusterGenerator[graph_]:=(
l=EdgeList[graph];
n=VertexCount[graph];
(* List all the connectec verteces *)
listTheEdge=Table[{l[[i,1]],l[[i,2]]},{i,1,Length[l]}];
(* apply CZ-gate to the connected verteces *)
czlist=Table[
	CZ@@{listTheEdge[[i,1]],listTheEdge[[i,2]],n},{i,1,Length@listTheEdge}];
(* generates the matrix to apply at |ddd...dd\[RightAngleBracket] and get the graph state *)
generator=Dot@@czlist;

(* return the graph state *)
Return[generator.kron@@Table[d,{n}]];
);
];


Module[{subGraph,diffGraph,complementGraph,out},
FindLUequivalent[graph_,vertex_]:=(
(* Select the subgraph generated by the vertex and its neighbours *)
subGraph=Subgraph[graph,AdjacencyList[graph,vertex]];
(* Complement the sub graph *)
complementGraph=GraphComplement[subGraph];
(* remove the starting subgraph *)
diffGraph=GraphDifference[graph,subGraph];
(* Union the new subGraph with the remaining main graph *)
out=GraphUnion[diffGraph,complementGraph,

VertexShapeFunction->"Circle",
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

];

(* return the LC-equivalent graph *)
Return[out];);];


Module[{perm,prmList,noDuplicates},
LUfamily[graph_]:=(
perm=Permutations[Range[VertexCount[graph]],VertexCount[graph]];
prmList=FoldList[FindLUequivalent,graph,#]&/@perm//Flatten;
noDuplicates=DeleteDuplicates[prmList,IsomorphicGraphQ];
Return[noDuplicates];)];


Module[{perm,prmList,noDuplicates},
LUfamilyISO[graph_]:=(
perm=Permutations[Range[VertexCount[graph]],VertexCount[graph]];
prmList=FoldList[FindLUequivalent,graph,#]&/@perm//Flatten;
noDuplicates=Select[prmList,IsomorphicGraphQ[#,graph]&];
Return[noDuplicates];)];


Module[{edgeDelete},
Zmeasurement[graph_,vertex_]:=(
edgeDelete=Complement[EdgeList[graph],EdgeList[graph,vertex\[UndirectedEdge]_]];
Return[Graph[edgeDelete,

VertexShapeFunction->"Circle",
VertexSize->0.4,
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

]];
);
];


Module[{dim,ops,opsList,coding,codingState,allStates,pos},
FindSGroupXZSymbolic[state_]:=(
dim=1/Log[Length[state],2];
ops=Tuples[Table[{\[DoubleStruckCapitalI][i],X[i],Z[i],-Z[i]},{i,1,dim}]];
opsList=Flatten[#/.opRules]&/@ops;
coding=kron@@Table[{H[i],V[i]},{i,1,dim}]//Flatten;
codingState=Total[state*coding];
allStates=codingState/.#&/@opsList;
pos=Position[#==(codingState)&/@allStates,True]//Flatten;
Return[ops[[pos]]])
];


Module[{dim,listStab,comb,cliffOp,combCliff,stabComb,graphGen,noSameNodeList,posStab,graphList},
FindGraphFromXZStab[state_]:=(
(* compute dimension of the input state *)
dim=1/Log[Length[state],2];
(* call function FindSGroupXZSymbolic to get a list of stabilizers from all comb of I,X,Z and -Z*)
(* As the phase -Z does not matter for finding the graph state, remove it *)
(* e.g. -Z,I and Z,I stabilize two different states but the same graph state *)
(* note that the ideal routine would be to find only the stabilizer generators, still open problem *)
listStab=Union[FindSGroupXZSymbolic[state]/.{-Z[qubit_]->Z[qubit]}];
(* consider all combinations of hadamard and Identity, should be enought... *)
comb=Tuples[{Table[HADA[i],{i,dim}],Table[ID[i],{i,dim}](*,Table[PH[i],{i,dim}]*)}\[Transpose]];
(* set the replacement rules *)
cliffOp={
HADA[qubit_]->{\[DoubleStruckCapitalI][qubit]->\[DoubleStruckCapitalI][qubit],X[qubit]->Z[qubit],Y[qubit]->Y[qubit],Z[qubit]->X[qubit]},
(*PH[qubit_]\[Rule]{\[DoubleStruckCapitalI][qubit]->\[DoubleStruckCapitalI][qubit],X[qubit]\[Rule]Y[qubit],Y[qubit]\[Rule]X[qubit],Z[qubit]\[Rule]Z[qubit]},*)
ID[qubit_]->{\[DoubleStruckCapitalI][qubit]->\[DoubleStruckCapitalI][qubit],X[qubit]->X[qubit],Y[qubit]->Y[qubit],Z[qubit]->Z[qubit]}};
(* take the first half of all the comb ;;2^(dim-1) and replace comb with a list of rules *)
(* the second half is symmetric and will give the same results *)
combCliff=Flatten[#]&/@(comb[[;;(2^(dim-1))]]/.cliffOp);
(* apply the rules on the stabilizers *)
stabComb=listStab/.combCliff;
(* select only those with one X per group of stabilizers *)
graphGen=Select[
Select[#,Count[#,X[_]]==1&]&/@stabComb,
Length@#>=dim&];
(* select only those with an X per node *)
noSameNodeList=Table[
Count[graphGen[[el]],#]&/@Table[{___,X[i],___},{i,1,dim}],
{el,Length@graphGen}];
(* find thir positions *)
posStab=Position[noSameNodeList,Table[1,dim]];
(* return the list *)
graphList=graphGen[[#]]&/@posStab;
Return[Flatten[graphList,1]])
];


Module[{linkList,nodeList,toGraph,noDoubleLinks},
DrawGraphFromStab[stabList_]:=(
linkList=Flatten[#]&/@(Position[#,Z[_]]&/@stabList);
nodeList=Flatten[(Position[#,X[_]]&/@stabList)];
toGraph=Table[
nodeList[[i]]\[UndirectedEdge]#&/@linkList[[i]],
{i,Length@nodeList}];
noDoubleLinks=DeleteDuplicates[Flatten[toGraph],#1==Reverse[#2]&];
Return[Graph[noDoubleLinks,

VertexShapeFunction->"Circle",
VertexSize->0.4,
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

]])
];


Module[{edgeDelete},
Zmeasurement[graph_,vertex_]:=(
edgeDelete=Complement[EdgeList[graph],EdgeList[graph,vertex\[UndirectedEdge]_]];
Return[Graph[edgeDelete,

VertexShapeFunction->"Circle",
VertexSize->0.4,
VertexStyle->Directive[EdgeForm[{Thick,Black}],LightPurple],
EdgeStyle->Directive[Black,Thick],
VertexLabels->Placed["Name",{1/2,1/2}],
VertexLabelStyle->Directive[Black,FontFamily->"YuMincho",15],
VertexSize->0.4

]];
);
];


Ymeasurement[graph_,vertex_]:=(
Return[
Zmeasurement[
FindLUequivalent[graph,vertex],vertex]]);


Module[{randomNeighbour,tempGraph},
Xmeasurement[graph_,vertex_]:=(
randomNeighbour=RandomChoice@AdjacencyList[graph,vertex];
tempGraph=Ymeasurement[FindLUequivalent[graph,randomNeighbour],vertex];

Return[
FindLUequivalent[tempGraph,randomNeighbour]]);
];



userColor = Lighter@Gray;
networkColor = White;

CustomGraphStyle[graph_]:= Graph[graph, VertexStyle -> {
    1 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    2 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    5 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    6 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], userColor],
    4 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], networkColor],
    3 -> Directive[EdgeForm[{Thick, Opacity[1], Black}], networkColor]},
VertexLabelStyle -> Directive[Black, FontFamily -> "IBM Plex Serif", 25],
EdgeStyle -> Directive[Black, Thick, Opacity[1]],
GraphLayout -> "CircularEmbedding"];


End[]


EndPackage[]
